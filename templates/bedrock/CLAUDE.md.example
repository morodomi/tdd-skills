# [Project Name] - WordPress Plugin/Theme

## Project Overview

- **Type**: WordPress Plugin / Theme
- **Framework**: Bedrock (WordPress)
- **PHP**: 8.1+
- **Test Framework**: PHPUnit 9.6 + wp-phpunit 6.8
- **Quality Tools**: PHPStan Level 8, Laravel Pint, Brain Monkey

## TDD Workflow

このプロジェクトは厳格なTDD（Test-Driven Development）ワークフローに従います。

**重要**: すべての変更は例外なくTDDサイクルを通してください。

### 7つのフェーズ

すべての機能開発は以下の順序で進めてください：

```
INIT → PLAN → RED → GREEN → REFACTOR → REVIEW → COMMIT
```

1. **INIT（初期化）**: 要件定義とTDDドキュメント作成
2. **PLAN（計画）**: 実装計画とテストケース一覧の作成
3. **RED（失敗するテスト）**: テストコードを先に作成（失敗することを確認）
4. **GREEN（実装）**: テストを通すための最小限の実装
5. **REFACTOR（リファクタリング）**: コード品質の改善（テストは維持）
6. **REVIEW（品質検証）**: テストカバレッジと静的解析の確認
7. **COMMIT（コミット）**: 変更をGitにコミット

### フェーズの開始方法

Claude Codeで以下のコマンドを入力:
- `init` または `/tdd-init`: INITフェーズ開始
- `plan` または `/tdd-plan`: PLANフェーズ開始
- `red` または `/tdd-red`: REDフェーズ開始
- `green` または `/tdd-green`: GREENフェーズ開始
- `refactor` または `/tdd-refactor`: REFACTORフェーズ開始
- `review` または `/tdd-review`: REVIEWフェーズ開始
- `commit` または `/tdd-commit`: COMMITフェーズ開始

### フェーズ自動遷移

各フェーズ完了時に自動的に次のフェーズに遷移します（ユーザー確認なし）。

---

## バグ修正・エラー対応のTDDフロー

エラーや不具合を発見した場合も、**必ずTDDサイクルを通してください**。

### 絶対ルール

> **「エラーを見つけたら、まずテストを書く」**

- ❌ エラーを見つけた → すぐにコードを修正
- ✅ エラーを見つけた → 再現テストを作成 → 修正 → テスト成功確認

**例外はありません。緊急時・本番障害・セキュリティ脆弱性であっても、必ずテストを先に書いてください。**

### バグ修正の手順

1. **INIT**: バグの再現条件を記録（`docs/` に簡易ドキュメント作成）
2. **RED**: バグを再現するテストを作成（失敗することを確認）
3. **GREEN**: バグを修正（テストが通ることを確認）
4. **REFACTOR**: 必要に応じてリファクタリング
5. **REVIEW**: 他の機能への影響確認
6. **COMMIT**: 修正をコミット

### なぜテストが必要か？

1. **再発防止**: 同じバグが再び発生しない
2. **影響範囲の把握**: 他の機能が壊れていないか確認
3. **ドキュメント化**: バグの内容と修正方法が記録される
4. **リファクタリングの安全性**: 将来の変更時に安心
5. **本当に直ったか確認**: 修正が正しいことを証明

---

## AIアシスタントへの厳格な指示

AIアシスタント（Claude、GitHub Copilot等）は、以下のルールを**絶対に**守ってください：

### 1. エラー発見時の対応

ユーザーがエラーや不具合を報告した場合：

❌ **禁止**:
```
修正しました。[修正内容]
```

✅ **必須**:
```
エラーを確認しました。TDDサイクルで対応しましょう。

まず、このエラーを再現するテストを作成します。
テストが失敗することを確認してから、修正を実装します。

1. RED: 再現テストを作成しますか？
```

### 2. コード修正依頼時の対応

ユーザーが「〜を修正して」と依頼した場合：

❌ **禁止**:
```
以下のように修正しました：
[修正コード]
```

✅ **必須**:
```
修正する前に、テストを作成しましょう。

現在の問題を再現するテストケースを作成します。
その後、テストを通すように修正を実装します。

TDDサイクルで進めますか？
```

### 3. 「急いでいる」と言われた場合

ユーザーが「急いでいるから直接修正して」と言った場合：

❌ **禁止**:
```
わかりました。直接修正します。
```

✅ **必須**:
```
急いでいる場合でも、テストを先に書くことで：
- 修正が正しいことを確認できます
- 他の機能を壊していないことを確認できます
- 同じバグの再発を防げます

テストの作成は数分で完了します。
TDDサイクルで進めましょう。

まず再現テストを作成します。
```

### 4. 例外は認めない

以下の状況でも、**必ずTDDサイクルを通してください**：

- 「小さな修正だから」 → ✗ 例外ではない
- 「本番環境で障害発生」 → ✗ テストを先に書く
- 「セキュリティ脆弱性」 → ✗ テストを先に書く
- 「顧客が待っている」 → ✗ テストを先に書く

**すべての変更は、テストファーストで進めてください。**

---

## TDDドキュメント管理

### ドキュメント配置

すべての機能開発・バグ修正は `docs/` ディレクトリにTDDドキュメントを作成してください。

**命名規則**: `docs/YYYYMMDD_hhmm_機能名.md`

**例**:
- `docs/20251105_1430_ユーザー登録機能.md`
- `docs/20251105_1600_バグ修正_ログインエラー.md`

### ドキュメント構成

```markdown
# 機能名: [機能名]

## INIT: 要件定義

### 背景
[なぜこの機能が必要か / バグの発生状況]

### 目標
[何を実現するか / バグをどう修正するか]

## PLAN: 実装計画

### テストケース一覧

#### 実装予定（TODO）
- [ ] TC-01: [テストケース]
- [ ] TC-02: [テストケース]

#### 実装中（WIP）
（現在作業中のテストケース）

#### 実装中に気づいた追加テスト（DISCOVERED）
（実装中に発見した新しいテストケース）

#### 完了（DONE）
- [x] TC-XX: [完了したテストケース]

### アーキテクチャ設計
[実装の設計方針]

## RED: テストコード

[失敗するテストコードの作成]

## GREEN: 実装

[テストを通すための実装]

## REFACTOR: リファクタリング

[コード品質の改善]

## REVIEW: 品質検証

### テスト結果
- カバレッジ: XX%
- 静的解析: エラー0件

### チェックリスト
- [ ] すべてのテストが成功
- [ ] カバレッジ目標達成
- [ ] 静的解析エラー0件
- [ ] コーディング規約準拠

## COMMIT: コミット情報

コミットハッシュ: [hash]
```

---

## テストリストの管理

### 重要な原則

実装中に新しいテストケースや問題に気づいた場合：

1. **今すぐ対応しない**
2. **テストリストに追加する**
3. **今のタスクに集中する**
4. **次のサイクルで対応する**

### 追加方法

TDDドキュメントの「実装中に気づいた追加テスト（DISCOVERED）」セクションに追記：

```markdown
### 実装中に気づいた追加テスト（DISCOVERED）
- [ ] TC-XX: [新しいテストケース]（[フェーズ]中に気づいた - Priority: [High/Medium/Low]）
```

**例**:
```markdown
- [ ] TC-04: パスワードリセット機能（GREEN中に気づいた - Priority: High）
- [ ] TC-05: セッション有効期限（REFACTOR中に気づいた - Priority: Medium）
```

### 優先度の判断

- **Priority: High**: 今実装中の機能に直接影響（次のサイクルで対応）
- **Priority: Medium**: 関連性が高い（近いうちに対応）
- **Priority: Low**: 将来的に必要（時間があれば対応）

---

## 各フェーズでの注意点

### INIT フェーズ
- TDDドキュメントを作成
- 要件を明確化
- 実装コードは書かない

### PLAN フェーズ
- テストケース一覧を作成
- アーキテクチャ設計を記述
- 実装コードは書かない

### RED フェーズ
- テストコードを先に作成
- テストが失敗することを確認
- 実装コードは書かない

### GREEN フェーズ
- テストを通すための最小限の実装
- YAGNI原則（必要になるまで実装しない）
- ハードコードも許容

### REFACTOR フェーズ
- コード品質を改善
- テストは維持（すべて成功し続けること）
- 重複排除、命名改善、構造改善

### REVIEW フェーズ
- テストカバレッジ確認
- 静的解析実行
- コーディング規約チェック
- すべての品質基準を満たす

### COMMIT フェーズ
- テストリストの状態を記録
- わかりやすいコミットメッセージ
- 次のサイクルへの引き継ぎ

---

## フェーズ遷移のルール

- 各フェーズは順番に実行する（スキップ禁止）
- 前のフェーズが完了するまで次に進まない
- REVIEW フェーズで品質基準を満たさない場合は REFACTOR に戻る
- **どんな理由があっても、REDフェーズ（テスト作成）をスキップしてはいけない**

---

## Quality Standards

このプロジェクトは以下の品質基準を遵守します。

### テストカバレッジ

- **目標**: 90%以上
- **最低ライン**: 80%
- **測定**: `composer test -- --coverage-text`

### 静的解析

- **PHPStan Level 8** (最高レベル) 必須
- **エラー許容**: 0件
- **実行**: `composer stan` または `vendor/bin/phpstan analyse`

### コーディング規約

- **Laravel Pint** (PSR-12準拠)
- **実行**: `composer pint`
- **WordPress Coding Standards** 準拠

### テスト形式

- **#[Test]属性形式** でテストを記述
- **Given/When/Then/And** コメントで意図を明確化
- **Unit/Integration** テストを適切に分離

---

## Docker Environment

### コンテナ内でテスト実行

このプロジェクトはDockerコンテナ内で実行されます。

#### プラグインのテスト

```bash
docker exec <container> bash -c "cd /var/task/web/app/mu-plugins/<plugin-name> && composer test"
```

#### テーマのテスト

```bash
docker exec <container> bash -c "cd /var/task/web/app/themes/<theme-name> && composer test"
```

#### 実行例

```bash
# プラグイン: thenews-weather
docker exec thenews-app-1 bash -c "cd /var/task/web/app/mu-plugins/thenews-weather && composer test"

# テーマ: thenews-theme
docker exec thenews-app-1 bash -c "cd /var/task/web/app/themes/thenews-theme && composer test"
```

### カバレッジ取得

```bash
docker exec <container> bash -c "cd /path/to/component && composer test -- --coverage-text"
```

### 静的解析実行

```bash
docker exec <container> bash -c "cd /path/to/component && composer stan"
```

### コーディング規約チェック

```bash
docker exec <container> bash -c "cd /path/to/component && composer pint"
```

---

## Git Subtree Configuration

このプロジェクトはGit Subtreeで複数のコンポーネントを管理しています。

### 開発ワークフロー

#### 1. 親リポジトリで作業

```bash
cd /path/to/bedrock-project

# プラグイン開発
cd web/app/mu-plugins/my-plugin

# TDDワークフローを実行
# Claude Codeで「init」と入力
```

#### 2. Subtreeへプッシュ

```bash
# 親リポジトリのルートに戻る
cd /path/to/bedrock-project

# Subtreeにプッシュ
git subtree push --prefix=web/app/mu-plugins/my-plugin my-plugin main
```

#### 3. Subtreeから更新を取得

```bash
# 親リポジトリのルートで実行
git subtree pull --prefix=web/app/mu-plugins/my-plugin my-plugin main
```

### 注意事項

- 各コンポーネントは独立したテスト環境を持つ
- Subtreeディレクトリ内で `.claude/skills` を配置可能
- 親リポジトリとSubtreeの両方で ClaudeSkills を使える

### Subtreeの追加（初回のみ）

```bash
# リモート追加
git remote add my-plugin git@github.com:username/my-plugin.git

# Subtree追加
git subtree add --prefix=web/app/mu-plugins/my-plugin my-plugin main --squash
```

---

## WordPress Development Guidelines

### セキュリティ対策（必須）

#### 入力のサニタイズ

すべてのユーザー入力を必ずサニタイズ:

```php
$text = sanitize_text_field($_POST['input']);
$content = sanitize_textarea_field($_POST['content']);
$html = wp_kses_post($_POST['html']);
$url = esc_url_raw($_POST['url']);
$email = sanitize_email($_POST['email']);
```

#### 出力のエスケープ

すべての出力を必ずエスケープ:

```php
echo esc_html($user_input);
echo '<div data-value="' . esc_attr($value) . '">';
echo '<a href="' . esc_url($link) . '">';
```

#### Nonce検証

フォーム送信時は必ずNonceを検証:

```php
// フォーム生成
wp_nonce_field('my_action', 'my_nonce');

// フォーム処理
if (!isset($_POST['my_nonce']) || !wp_verify_nonce($_POST['my_nonce'], 'my_action')) {
    wp_die('Security check failed');
}
```

#### 権限チェック

管理機能には必ず権限チェック:

```php
if (!current_user_can('manage_options')) {
    wp_die('You do not have sufficient permissions');
}
```

### WordPress関数の優先使用

直接DBアクセスではなく、WordPress関数を使用:

```php
// ✅ Good
wp_insert_post(['post_title' => $title]);
update_post_meta($post_id, 'key', $value);
$value = get_option('option_name');

// ❌ Bad
global $wpdb;
$wpdb->query("INSERT INTO ...");
```

### Hooks/Filters

機能を拡張可能にする:

```php
// フィルタで値を変更可能に
$value = apply_filters('my_plugin_value', $default_value);

// アクションで処理を追加可能に
do_action('my_plugin_before_save', $data);
save_data($data);
do_action('my_plugin_after_save', $data);
```

### 国際化対応

すべての文字列を翻訳可能に:

```php
echo esc_html__('Weather Information', 'my-plugin');
printf(
    esc_html__('Weather in %s', 'my-plugin'),
    esc_html($city)
);
```

---

## Available Commands

### テスト実行

```bash
# すべてのテスト
composer test

# Unitテストのみ
composer test:unit

# Integrationテストのみ
composer test:integration

# カバレッジ付き
composer test -- --coverage-text
```

### 静的解析

```bash
# PHPStan実行
composer stan

# または
vendor/bin/phpstan analyse --memory-limit=1G
```

### コーディング規約

```bash
# Pint実行（チェックのみ）
composer pint

# Pint実行（自動修正）
composer pint:fix
```

### すべてのチェック

```bash
# Pint + PHPStan + Test
composer check
```

---

## Testing Guidelines

### テストディレクトリ構造

```
tests/
├── Unit/              # 純粋なPHPロジック（WordPress環境不要）
│   └── *Test.php      # PHPUnit\Framework\TestCase を継承
├── Integration/       # WordPress環境が必要
│   └── *Test.php      # WP_UnitTestCase を継承
└── bootstrap.php      # wp-phpunitセットアップ
```

### テストクラスの選択

#### WP_UnitTestCase を使うケース

- WordPress関数（`get_option`, `wp_insert_post`等）を実行する
- データベース操作を伴う
- WordPressフック/フィルタを使用する

```php
use WP_UnitTestCase;
use PHPUnit\Framework\Attributes\Test;

class IntegrationTest extends WP_UnitTestCase
{
    #[Test]
    public function widget_saves_settings(): void
    {
        // Given/When/Then...
    }
}
```

#### PHPUnit\Framework\TestCase を使うケース

- 純粋なPHPロジック（WordPress関数を使わない）
- 高速なユニットテスト
- Brain Monkeyでモック化可能なケース

```php
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\Attributes\Test;
use Brain\Monkey\Functions;

class UnitTest extends TestCase
{
    protected function setUp(): void
    {
        parent::setUp();
        \Brain\Monkey\setUp();
    }

    protected function tearDown(): void
    {
        \Brain\Monkey\tearDown();
        parent::tearDown();
    }

    #[Test]
    public function uses_cached_value(): void
    {
        // Given: WordPress関数をモック
        Functions\expect('get_transient')
            ->once()
            ->andReturn(['data' => 'value']);

        // When/Then...
    }
}
```

---

## Commit Guidelines

### コミットメッセージ形式

```
feat: 新機能を追加
fix: バグ修正
docs: ドキュメント更新
refactor: リファクタリング
test: テスト追加・修正
chore: ビルド、補助ツール等の変更
```

### 例

```bash
git commit -m "feat: 天気ウィジェットのショートコード実装"
git commit -m "fix: 気温表示のエスケープ処理を追加"
git commit -m "test: 天気データ取得のテストケース追加"
```

---

## Development Workflow Example

```
1. Claude Codeで「init」と入力
   → TDDドキュメント（docs/YYYYMMDD_hhmm_天気ウィジェット.md）が作成される

2. PLANフェーズで実装計画とテストケースを定義
   → 自動的にREDフェーズへ遷移

3. REDフェーズでテスト作成
   → tests/Unit/WeatherServiceTest.php
   → tests/Integration/WeatherWidgetTest.php
   → 自動的にGREENフェーズへ遷移

4. GREENフェーズで最小限の実装
   → src/WeatherService.php
   → 自動的にREFACTORフェーズへ遷移

5. REFACTORフェーズでリファクタリング
   → コードを改善
   → 自動的にREVIEWフェーズへ遷移

6. REVIEWフェーズで品質チェック
   → PHPStan Level 8: 0 errors
   → カバレッジ: 95%
   → セキュリティ: サニタイズ/エスケープ OK
   → 自動的にCOMMITフェーズへ遷移

7. COMMITフェーズでコミット
   → git add .
   → git commit -m "feat: 天気ウィジェット実装"
```

---

## Notes for Claude Code

### メタルール

- コードの動作、ファイル場所、システム状態について不確実な場合は**推測せず、ユーザーに明確化を求める**
- 「おそらく〜」「〜だと思います」などの曖昧な表現を避ける
- 絶対に必要でない限り、新規ファイルを作成しない
- **既存ファイルの編集を新規作成より優先する**

### ユーザーへの選択肢提示ルール

ユーザーに選択を求める際は、**必ず以下の形式**で提示してください：

#### 必須要素

1. **推奨度**: ★（星）5段階で表現（★☆☆☆☆ ～ ★★★★★）
2. **理由**: 各選択肢を推奨する/しない理由を明記

#### 提示形式

```
選択肢:
1. [推奨★★★★★] [選択肢の内容]
   理由: [この選択肢を強く推奨する理由]

2. [推奨★★★★☆] [選択肢の内容]
   理由: [この選択肢の理由・メリット]

3. [推奨★★★☆☆] [選択肢の内容]
   理由: [中立的・状況次第の理由]

4. [推奨★★☆☆☆] [選択肢の内容]
   理由: [あまり推奨しない理由・デメリット]

どうしますか？
```

#### 推奨度の目安

- **★★★★★ (強く推奨)**:
  - 95%以上のケースで最適
  - 最も一般的で適切な選択肢
  - リスクが低く、効率的
  - 初心者でも安全

- **★★★★☆ (推奨)**:
  - 70-94%のケースで最適
  - 一般的に良い選択肢
  - 条件が揃えば最適
  - 実績がある

- **★★★☆☆ (中立・状況次第)**:
  - 50-69%のケースで有効
  - メリットとデメリットが半々
  - 特定の条件下で有効
  - 状況によっては最適

- **★★☆☆☆ (あまり推奨しない)**:
  - 30-49%のケースで有効
  - デメリットが多い
  - リスクや手間が大きい
  - 限定的な状況でのみ有効

- **★☆☆☆☆ (非推奨)**:
  - 30%未満のケースでのみ有効
  - 特殊なケースのみ
  - 他の選択肢が使えない場合のみ
  - 避けるべき

#### 例1: Overviewドキュメントが存在しない場合

```
選択肢:
1. [推奨★★★★★] このまま進める（CLAUDE.md/README.mdで十分な情報がある）
   理由: 小規模プロジェクトでは過剰な構造化は不要。95%のケースでこれが最適

2. [推奨★★★★☆] PLANフェーズで必要なら作成する
   理由: 実際に必要性を感じてから作成する方が効率的。柔軟な対応

3. [推奨★★☆☆☆] 今すぐOverview docを作成する（時間がかかる）
   理由: 時間がかかる。大規模化が確実な場合のみ有効

どうしますか？
```

#### 例2: 既存のTDDサイクルが進行中の場合

```
選択肢:
1. [推奨★★★★★] 既存のTDDサイクルを継続する（INITは不要）
   理由: 複数サイクルを並行すると混乱しやすい。完了してから新規開始が安全

2. [推奨★★☆☆☆] 新しいサイクルを開始する（既存サイクルと並行開発）
   理由: 独立した機能で影響がない場合のみ有効。管理コストが増加

どうしますか？
```

#### 例3: テストフレームワーク選択（4個の選択肢）

```
選択肢:
1. [推奨★★★★★] PHPUnit + Pest
   理由: モダンな記法とPHPUnitの安定性の両立。Laravelプロジェクトで最適

2. [推奨★★★★☆] PHPUnit のみ
   理由: 実績豊富で安定。チームが慣れている場合に推奨

3. [推奨★★★☆☆] Pest のみ
   理由: モダンで読みやすいが、PHPUnitの機能が必要な場合は不足

4. [推奨★★☆☆☆] Codeception
   理由: E2Eテスト向け。単体・統合テストには過剰な機能

どうしますか？
```

#### 禁止事項

❌ **推奨度や理由なしの選択肢提示**:
```
選択肢:
1. このまま進める
2. Overview docを作成する
3. PLANフェーズで作成する
```

✅ **正しい提示方法**（上記の例参照）

### WordPress開発での重要原則

1. **セキュリティファースト**: サニタイズ/エスケープ/Nonce検証は必須
2. **WordPress関数優先**: 直接DBアクセスを避ける
3. **拡張性**: Hooks/Filtersで拡張可能にする
4. **国際化**: すべての文字列を翻訳可能に
5. **テスト分離**: Unit/Integration を適切に分離

### Docker環境での開発

- テスト実行は必ずDockerコンテナ内で実行
- ローカル環境での実行は避ける
- コンテナ名とパスを確認してから実行

---

*最終更新: [YYYY-MM-DD]*
*ClaudeSkills Version: [バージョン]*
