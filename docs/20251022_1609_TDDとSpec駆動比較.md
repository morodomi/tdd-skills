# TDD vs Spec駆動開発（BDD）比較

**作成日**: 2025-10-22
**目的**: TDDとSpec駆動開発の違いを理解し、最適なワークフローを決定する

---

## 1. 概要

### TDD (Test-Driven Development)
**テスト駆動開発**: テストを先に書き、そのテストを通すコードを実装する

### BDD (Behavior-Driven Development)
**振る舞い駆動開発**: ビジネス要件や振る舞いを仕様として記述し、それを満たすコードを実装する

### Spec-Driven Development
**仕様駆動開発**: BDDの一種。特にPHPSpecのようなツールを使った仕様ベースの開発を指す

---

## 2. 主要な違い

### 2.1 開発の方向性

| | TDD | BDD/Spec駆動 |
|---|-----|--------------|
| **アプローチ** | Inside-Out（内側から外側） | Outside-In（外側から内側） |
| **開始点** | 単体テスト（Unit Test） | ユーザーストーリー / 振る舞い仕様 |
| **焦点** | コードの正確性 | システムの振る舞い |
| **視点** | 開発者中心 | ユーザー/ビジネス中心 |

#### Inside-Out vs Outside-In

```
TDD (Inside-Out):
モデル → サービス → コントローラー → ビュー
  ↓
最小単位から構築して外側へ

BDD (Outside-In):
ユーザーストーリー → 受け入れテスト → 実装 → 単体仕様
  ↓
ユーザー視点から始めて内側へ
```

### 2.2 誰が関与するか

| | TDD | BDD |
|---|-----|-----|
| **主な担当者** | 開発者 | 開発者 + PO + QA + ステークホルダー |
| **協調** | 開発者単独で実行可能 | チーム全体でのコラボレーション |
| **コミュニケーション** | コード中心 | 自然言語の仕様書 |

### 2.3 テストの記述方法

#### TDD (PHPUnit)
```php
// tests/Unit/UserTest.php
class UserTest extends TestCase
{
    /** @test */
    public function it_can_update_profile()
    {
        $user = User::factory()->create();

        $user->updateProfile(['name' => 'New Name']);

        $this->assertEquals('New Name', $user->fresh()->name);
    }
}
```

**特徴**:
- プログラミング言語で記述
- メソッド単位のテスト
- 技術的な詳細に焦点

#### BDD - StoryBDD (Behat)
```gherkin
# features/user_profile.feature
Feature: User Profile Management
  As a registered user
  I want to update my profile
  So that I can keep my information current

  Scenario: User updates their name
    Given I am logged in as "john@example.com"
    And I am on the profile page
    When I fill in "name" with "John Doe"
    And I press "Save"
    Then I should see "Profile updated successfully"
    And my name should be "John Doe"
```

**特徴**:
- 自然言語（Gherkin）で記述
- ユーザーストーリー単位
- ビジネス価値に焦点

#### BDD - SpecBDD (PHPSpec)
```php
// spec/UserSpec.php
class UserSpec extends ObjectBehavior
{
    function it_updates_profile_name()
    {
        $this->updateProfile(['name' => 'New Name']);

        $this->getName()->shouldReturn('New Name');
    }

    function it_throws_exception_for_invalid_name()
    {
        $this->shouldThrow(\InvalidArgumentException::class)
             ->during('updateProfile', [['name' => '']]);
    }
}
```

**特徴**:
- 「仕様」言語で記述（`shouldReturn`, `shouldThrow`）
- オブジェクトの振る舞いに焦点
- TDDより読みやすい

---

## 3. PHP/Laravelでのツール比較

### 3.1 テストツールの位置づけ

```
┌─────────────────────────────────────────┐
│  Behat (StoryBDD)                       │  ← ユーザー視点
│  - Gherkin記法                          │
│  - 受け入れテスト                       │
│  - 統合テスト                           │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  PHPSpec (SpecBDD)                      │  ← 設計視点
│  - 仕様記述                             │
│  - オブジェクト設計                     │
│  - 単体仕様                             │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  PHPUnit (TDD)                          │  ← 実装視点
│  - 単体テスト                           │
│  - 統合テスト                           │
│  - 機能テスト                           │
└─────────────────────────────────────────┘
```

### 3.2 ツールの特徴

#### PHPUnit
- **用途**: 汎用テストフレームワーク
- **Laravel統合**: 標準搭載
- **学習コスト**: 低い（Laravel開発者なら既知）
- **適用範囲**: 単体 / 機能 / 統合すべて
- **記法**: アサーション（`assertEquals`, `assertTrue`）

#### PHPSpec
- **用途**: SpecBDD、オブジェクト設計
- **Laravel統合**: サードパーティ（`phpspec-laravel`）
- **学習コスト**: 中程度（BDDマインドセット必要）
- **適用範囲**: 単体仕様、設計レベル
- **記法**: 振る舞い記述（`shouldReturn`, `shouldThrow`）
- **特徴**: コード生成機能あり

#### Behat
- **用途**: StoryBDD、受け入れテスト
- **Laravel統合**: サードパーティ（`laracasts/behat-laravel-extension`）
- **学習コスト**: 中〜高（Gherkin + ステップ定義）
- **適用範囲**: 機能テスト、E2Eテスト
- **記法**: Gherkin（Given/When/Then）
- **特徴**: 非エンジニアと共有可能

#### Pest
- **用途**: PHPUnitの代替（モダンな記法）
- **Laravel統合**: 公式サポート（Laravel 8+）
- **学習コスト**: 低い（PHPUnitより直感的）
- **適用範囲**: 単体 / 機能 / 統合すべて
- **記法**: クロージャベース（`it()`, `expect()`）

---

## 4. ワークフローの比較

### 4.1 TDDワークフロー

```
1. RED: テストを書く（失敗する）
   ↓
2. GREEN: 最小限の実装でテストを通す
   ↓
3. REFACTOR: リファクタリング
   ↓
繰り返し
```

**具体例**:
```bash
# 1. RED
./vendor/bin/phpunit tests/Unit/UserTest.php
# → Failed: Call to undefined method updateProfile()

# 2. GREEN
# User.phpにupdateProfile()メソッドを実装
./vendor/bin/phpunit tests/Unit/UserTest.php
# → OK

# 3. REFACTOR
# コードをきれいにする
./vendor/bin/phpunit tests/Unit/UserTest.php
# → OK (維持)
```

### 4.2 BDDワークフロー（Behat + PHPSpec）

```
1. STORY: ユーザーストーリーを書く（Gherkin）
   ↓
2. RED (Behat): ストーリーのテストを実行（失敗）
   ↓
3. SPEC (PHPSpec): 必要なオブジェクトの仕様を記述
   ↓
4. RED (PHPSpec): 仕様のテストを実行（失敗）
   ↓
5. GREEN (PHPSpec): 実装してテストを通す
   ↓
6. REFACTOR (PHPSpec): リファクタリング
   ↓
7. GREEN (Behat): ストーリーのテストを通す
   ↓
繰り返し
```

**具体例**:
```bash
# 1. STORY
# features/user_profile.feature を作成

# 2. RED (Behat)
./vendor/bin/behat
# → Undefined step: "I am on the profile page"

# 3-6. PHPSpec循環
./vendor/bin/phpspec run
./vendor/bin/phpspec run
# → OK

# 7. GREEN (Behat)
./vendor/bin/behat
# → OK
```

### 4.3 ハイブリッドワークフロー（推奨）

```
1. INIT: 要件定義
   ↓
2. STORY: ユーザーストーリー作成（Gherkin または PLAN.md）
   ↓
3. PLAN: 実装計画
   ↓
4. RED: テスト作成（PHPUnit/Pest）
   ↓
5. GREEN: 実装
   ↓
6. REFACTOR: リファクタリング
   ↓
7. ACCEPTANCE: 受け入れテスト（手動 or Behat）
   ↓
8. REVIEW: コードレビュー
   ↓
9. COMMIT
```

---

## 5. どちらを選ぶべきか

### 5.1 判断基準

| 状況 | 推奨 | 理由 |
|------|------|------|
| 個人開発 | **TDD (PHPUnit/Pest)** | シンプル、学習コスト低、十分 |
| チーム開発（技術者のみ） | **TDD (PHPUnit/Pest)** | PHPUnitで十分、追加ツール不要 |
| チーム開発（PO/QAあり） | **BDD (Behat + PHPUnit)** | ステークホルダーと仕様共有可 |
| 複雑なドメインロジック | **BDD (PHPSpec + PHPUnit)** | 設計と仕様を明確にできる |
| 既存プロジェクト | **TDD (PHPUnit/Pest)** | 既存のテストと統一できる |
| 新規プロジェクト | **TDD or BDD** | チーム構成による |

### 5.2 あなたのケース（個人開発、複数プロジェクト）

**推奨: TDD (PHPUnit/Pest) + ドキュメント駆動**

理由:
1. ✅ **個人開発**: BDDのコラボレーション機能は不要
2. ✅ **複数プロジェクト**: PHPUnit/Pestは全プロジェクトで使える
3. ✅ **学習コスト**: 既に使っているツールを活用
4. ✅ **Claude Codeとの親和性**: PLAN.mdがGherkinの代わりになる
5. ✅ **柔軟性**: Laravel/Django/Flask/WordPressすべてで統一

### 5.3 現在のワークフローとの比較

#### あなたの現在のワークフロー
```
INIT → PLAN (docs) → Doc Review → RED → GREEN → REFACTOR → Review → docs更新 → COMMIT
```

これは実質的に **「ドキュメント駆動BDD」** です。

- `PLAN.md` = Gherkinの代わり（ユーザーストーリー）
- `RED/GREEN/REFACTOR` = TDDサイクル
- `Doc Review` = 受け入れ基準の確認

**結論**: 既に最適なハイブリッドを実践しています。

---

## 6. BDDツールを導入すべきか？

### 6.1 導入するメリット

#### Behat導入のメリット
- ✅ Gherkin記法で仕様が明確になる
- ✅ 非エンジニアと仕様を共有できる（将来的にチーム化する場合）
- ✅ E2Eテストを自然言語で記述できる

#### PHPSpec導入のメリット
- ✅ オブジェクト設計がより明確になる
- ✅ コード生成機能で初期実装が楽になる
- ✅ 仕様と実装の乖離を防げる

### 6.2 導入しないデメリット

- ❌ 学習コストが増える
- ❌ ツールチェーンが複雑になる
- ❌ 既存のPHPUnit/Pestと重複する
- ❌ Claude Codeの振る舞いが複雑になる可能性

### 6.3 推奨判断

**現時点では導入不要**

理由:
1. 現在のワークフローで十分機能している
2. `PLAN.md` がGherkinの役割を果たしている
3. PHPUnit/Pestで実装レベルはカバーできている
4. 追加ツールはClaude Codeの制御を複雑にする

**導入を検討すべきケース**:
- チーム開発に移行する
- 非エンジニアのステークホルダーが参加する
- E2Eテストを自動化したい
- より厳密なオブジェクト設計が必要

---

## 7. Spec駆動の要素を取り入れる方法

BDDツールを導入せずに、**Spec駆動の良い部分だけ取り入れる**方法:

### 7.1 PLAN.mdをGherkin風にする

#### Before（現在）
```markdown
# ユーザープロフィール編集機能

## 概要
ユーザーが自分のプロフィールを編集できる機能

## 実装内容
- ProfileControllerを作成
- updateメソッドを実装
- バリデーション追加
```

#### After（Spec駆動風）
```markdown
# ユーザープロフィール編集機能

## ユーザーストーリー

**As a** 登録済みユーザー
**I want to** プロフィールを編集できる
**So that** 最新の情報を保つことができる

## 受け入れ基準

### シナリオ1: 正常なプロフィール更新
**Given** ログイン済みユーザーがプロフィールページにいる
**When** 名前を "John Doe" に変更して保存する
**Then** "プロフィールを更新しました" と表示される
**And** 名前が "John Doe" になっている

### シナリオ2: バリデーションエラー
**Given** ログイン済みユーザーがプロフィールページにいる
**When** 名前を空にして保存する
**Then** "名前は必須です" とエラーが表示される
**And** プロフィールは更新されない

## 実装内容
...
```

### 7.2 テストを振る舞い記述風にする

#### Before（TDD風）
```php
/** @test */
public function user_can_update_profile()
{
    $user = User::factory()->create();
    $response = $this->actingAs($user)->post('/profile', [
        'name' => 'New Name'
    ]);
    $this->assertEquals('New Name', $user->fresh()->name);
}
```

#### After（Spec駆動風 with Pest）
```php
it('allows logged-in user to update their profile name', function () {
    // Given: ログイン済みユーザー
    $user = User::factory()->create(['name' => 'Old Name']);
    actingAs($user);

    // When: 名前を変更して保存
    $response = post('/profile', ['name' => 'John Doe']);

    // Then: 成功メッセージが表示される
    expect($response)->toHaveSessionSuccess('プロフィールを更新しました');

    // And: 名前が更新されている
    expect($user->fresh()->name)->toBe('John Doe');
});

it('shows validation error when name is empty', function () {
    // Given: ログイン済みユーザー
    $user = User::factory()->create();
    actingAs($user);

    // When: 名前を空にして保存
    $response = post('/profile', ['name' => '']);

    // Then: エラーが表示される
    expect($response)->toHaveSessionError('name', '名前は必須です');

    // And: プロフィールは更新されない
    expect($user->fresh()->name)->toBe($user->name);
});
```

### 7.3 Claude Skills で Spec駆動マインドセットを注入

```markdown
---
name: tdd-red
description: REDフェーズ。テストコードのみを作成。Given/When/Then形式で振る舞いを記述。
allowed-tools: Read, Write, Grep, Glob
---

# TDD RED Phase - Behavior Specification

## このフェーズでやること

✅ PLAN.mdの受け入れ基準を読み取る
✅ Given/When/Then形式でテストを記述
✅ 振る舞いに焦点を当てる（実装詳細ではなく）

## テストの書き方

**悪い例**（実装詳細に焦点）:
```php
/** @test */
public function test_update_method()
{
    $user = new User();
    $user->update(['name' => 'Test']);
    // ...
}
```

**良い例**（振る舞いに焦点）:
```php
it('allows user to update their profile name', function () {
    // Given: ログイン済みユーザーがいる
    $user = User::factory()->create();
    actingAs($user);

    // When: プロフィールを更新する
    post('/profile', ['name' => 'New Name']);

    // Then: 名前が更新される
    expect($user->fresh()->name)->toBe('New Name');
});
```

## 次のステップ

すべてのテストを作成したら:
1. テストを実行して全て失敗することを確認
2. `/tdd-green` へ進むよう促す
```

---

## 8. まとめ

### 8.1 結論

| | 判断 | 理由 |
|---|------|------|
| **TDD vs BDD** | **TDD継続** | 個人開発には十分、Claude Codeとの相性良 |
| **BDDツール導入** | **不要** | 現在のワークフローで十分機能している |
| **Spec駆動の要素** | **部分的に取り入れる** | PLAN.mdをGherkin風に、テストを振る舞い記述風に |

### 8.2 推奨アクション

1. **現在のTDDワークフローを継続**
   - INIT → PLAN → RED → GREEN → REFACTOR → COMMIT

2. **Spec駆動の良い部分を取り入れる**
   - PLAN.mdにGiven/When/Then形式の受け入れ基準を追加
   - Pestで振る舞い記述風のテストを書く
   - Claude Skillsで「振る舞いに焦点を当てる」マインドセットを注入

3. **BDDツールは保留**
   - 将来的にチーム化する場合に検討
   - 現時点では学習コストとメリットが見合わない

### 8.3 参考: ツール選択マトリクス

```
現在の構成（推奨維持）:
┌────────────────────────────────────┐
│ PLAN.md (Gherkin風の受け入れ基準)  │
├────────────────────────────────────┤
│ PHPUnit/Pest (振る舞い記述風)      │
├────────────────────────────────────┤
│ PHPStan (静的解析)                 │
├────────────────────────────────────┤
│ Claude Skills (ワークフロー制御)    │
└────────────────────────────────────┘

将来的な拡張案（チーム化時）:
┌────────────────────────────────────┐
│ Behat (Gherkin + 自動化)           │
├────────────────────────────────────┤
│ PHPSpec (SpecBDD)                  │
├────────────────────────────────────┤
│ PHPUnit/Pest (統合テスト)          │
├────────────────────────────────────┤
│ PHPStan (静的解析)                 │
├────────────────────────────────────┤
│ Claude Skills (ワークフロー制御)    │
└────────────────────────────────────┘
```

---

## 9. 次のステップ

1. ✅ **TDDワークフローを継続する**
2. ✅ **PLAN.mdのテンプレートにGiven/When/Thenセクションを追加**
3. ✅ **tdd-red Skillに「振る舞い記述」のガイダンスを追加**
4. ⏭️ **必要に応じて将来BDDツールを検討**

---

*調査完了日: 2025-10-22*
*推奨: 現在のTDDワークフロー継続 + Spec駆動マインドセットの部分導入*
